import json
import re


class IrText2JsonConverter:
    NODE_PARSE_REGEX = r'^(?:(?P<context>(?:[$?\w]*?)|(?:<.*?>)): )?'\
            '(?P<type>(?:[A-Z_]+(?: |$))+)?'\
            '(?:(?P<lang_type>\w*?)(?: |$))?'\
            '(?:\'(?P<source_code>.*?)\')?'\
            '(?P<params_or_props>.*)$'
    PARAMS_PARSE_REGEX = r'(?=(?: |^)(\w+):(?:(?:\'(.*?)\')|(?:(.*?))(?: \w+:|$)))+'
    PROPS_PARSE_REGEX = r'(?=(?: |^)(\w+)=(?:(?:\'(.*?)\')|(?:(.*?))(?: \w+=|$)))+'

    def __init__(self, file):
        with open(file, 'r') as f:
            self.nodes = f.read().split('\n')

    def node_parse(self, node):
        node_parsed = re.search(self.NODE_PARSE_REGEX, node)
        node = {k: v for k, v in node_parsed.groupdict().items() if k != 'params_or_props' and v}

        if 'type' in node:
            node['type'] = node['type'].strip()

        params_or_props = node_parsed.group('params_or_props')
        if params_or_props:
            params_or_props_parsed = re.findall(self.PARAMS_PARSE_REGEX, params_or_props.strip())
            if params_or_props_parsed:
                node['params'] = {}
                node_params_or_props_section = node['params']
            else:
                params_or_props_parsed = re.findall(self.PROPS_PARSE_REGEX, params_or_props.strip())
                node['props'] = {}
                node_params_or_props_section = node['props']

            for name, value_quoted, value in params_or_props_parsed:
                node_params_or_props_section[name] = value_quoted if value_quoted else value

        return node

    def walk(self):
        root = None
        current_nodes = None
        current_level = 0
        parent_nodes = []

        for node in self.nodes:
            if not node:
                continue
            level = int(re.search('\S', node).start() / 2)

            if level > current_level and current_nodes:
                parent_nodes.append(current_nodes)
                current_nodes[-1]['children'] = []
                current_nodes = current_nodes[-1]['children']
                current_level = level
            elif level < current_level and current_nodes:
                for i in range(current_level - level):
                    current_nodes = parent_nodes.pop()
                current_level = level

            if level == 0:
                root = [{'node': self.node_parse(node.lstrip())}]
                current_nodes = root
            else:
                node_parsed = self.node_parse(node.lstrip())
                current_nodes.append(node_parsed)

        return root

    def convert(self):
        """
        Convert file with IR (generated by custom kotlin compiler - "academic version") to JSON
        """
        ir = self.walk()

        return json.dumps(ir)
